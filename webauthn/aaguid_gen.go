//go:build ignore

package main

import (
	"bytes"
	"cmp"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"go/format"
	"io"
	"log"
	"net/http"
	"os"
	"slices"
	"strings"
	"text/template"
)

var tmpl = template.Must(template.New("").Parse(`package webauthn

//go:generate go run aaguid_gen.go

// Code generated by aaguid_gen.go DO NOT EDIT.

// AAGUIDs listed by https://github.com/passkeydeveloper/passkey-authenticator-aaguids.
var passkeyAuthenticatorAAGUIDs = map[AAGUID]string{
	{{ range .PasskeyAuthenticatorAAGUIDs }}mustParseAAGUID("{{ .AAGUID }}"): "{{ .Name }}",
	{{ end }}
}

// AAGUIDs listed by https://fidoalliance.org/metadata/.
var metadataAAGUIDs = map[AAGUID]string{
	{{ range .MetadataAAGUIDs }}mustParseAAGUID("{{ .AAGUID }}"): "{{ .Name }}",
	{{ end }}
}
`))

const (
	passkeyAuthenticatorGitHub = "https://raw.githubusercontent.com/passkeydeveloper/passkey-authenticator-aaguids/refs/heads/main/aaguid.json"
	metadata                   = "https://mds3.fidoalliance.org/"
)

type aaguidName struct {
	AAGUID string
	Name   string
}

func compareAAGUIDName(a1, a2 aaguidName) int {
	return cmp.Or(
		// Order by the AAGUID first to make diffs more readable.
		cmp.Compare(a1.AAGUID, a2.AAGUID),
		cmp.Compare(a1.Name, a2.Name),
	)
}

func run() error {
	passkeyAAGUIDs, err := parsePasskeyAuthenticatorAAGUIDs()
	if err != nil {
		return fmt.Errorf("parsing passkey authenticator aaguids: %v", err)
	}
	slices.SortFunc(passkeyAAGUIDs, compareAAGUIDName)

	mdAAGUIDs, err := parseMetadata()
	if err != nil {
		return fmt.Errorf("parsing metadata: %v", err)
	}
	slices.SortFunc(mdAAGUIDs, compareAAGUIDName)

	data := struct {
		PasskeyAuthenticatorAAGUIDs []aaguidName
		MetadataAAGUIDs             []aaguidName
	}{passkeyAAGUIDs, mdAAGUIDs}

	buff := &bytes.Buffer{}
	if err := tmpl.Execute(buff, data); err != nil {
		return fmt.Errorf("rendering go file: %v", err)
	}

	srcBytes, err := format.Source(buff.Bytes())
	if err != nil {
		return fmt.Errorf("formatting go file: %v", err)
	}

	if err := os.WriteFile("aaguid.go", srcBytes, 0644); err != nil {
		return fmt.Errorf("writing aaguid file: %v", err)
	}
	return nil
}

func parseMetadata() ([]aaguidName, error) {
	resp, err := http.Get(metadata)
	if err != nil {
		return nil, fmt.Errorf("metadata: %v", err)
	}
	body, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("reading response body: %v", err)
	}
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code %s: %v", resp.Status, body)
	}

	parts := bytes.Split(body, []byte{'.'})
	if len(parts) != 3 {
		return nil, fmt.Errorf("expected jwt with three parts, got %d", len(parts))
	}
	payload, err := base64.RawURLEncoding.AppendDecode(nil, parts[1])
	if err != nil {
		return nil, fmt.Errorf("decoding jwt payload: %v", err)
	}
	var blob struct {
		Entries []struct {
			AAGUID   string `json:"aaguid"`
			Metadata struct {
				Description string `json:"description"`
			} `json:"metadataStatement"`
		} `json:"entries"`
	}
	if err := json.Unmarshal(payload, &blob); err != nil {
		return nil, fmt.Errorf("parsing blob: %v", err)
	}

	var names []aaguidName
	for _, e := range blob.Entries {
		aaguid := strings.TrimSpace(e.AAGUID)
		if aaguid == "" {
			continue
		}
		names = append(names, aaguidName{aaguid, e.Metadata.Description})
	}
	return names, nil
}

func parsePasskeyAuthenticatorAAGUIDs() ([]aaguidName, error) {
	resp, err := http.Get(passkeyAuthenticatorGitHub)
	if err != nil {
		return nil, fmt.Errorf("getting passkey authenticator aaguid: %v", err)
	}
	body, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("reading response body: %v", err)
	}
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code %s: %v", resp.Status, body)
	}

	var aaguids map[string]struct {
		Name string `json:"name"`
	}
	if err := json.Unmarshal(body, &aaguids); err != nil {
		return nil, fmt.Errorf("parsing body: %v", err)
	}
	var names []aaguidName
	for k, v := range aaguids {
		names = append(names, aaguidName{k, v.Name})
	}
	return names, nil
}

func main() {
	if err := run(); err != nil {
		log.Fatalf("Updating aaguid file: %v", err)
	}
}
